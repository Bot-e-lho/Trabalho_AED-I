#include "matrix.h"

Matrix* matrix_create( void ) {
    Matrix* matrix = ( Matrix* )malloc( sizeof( Matrix ) );

    matrix->line = -1;
    matrix->column = -1;
    matrix->right = matrix;
    matrix->below = matrix;

    int m = 0, n = 0, i = 0, j = 0;
    float valor = 0.0;

    scanf("%d %d", &m, &n);

    for( int a = 0; a < m; a++ ) {
        matrix_heads_line(matrix, a);
    }

    for( int b = 0; b < n; b++ ) {
        matrix_heads_column(matrix, b);
    }
    printf("\nInforme a coordenada(x,y) e o valor:\n");
    while( 1 ) {
        scanf("%d %d %f", &i, &j, &valor);
        if( i == -1 || j == -1 || valor == -1 || valor == 0 ) {
            break;
        }
        if( i >= 0 && i < m && j >= 0 && j < n ) {
            matrix_setelem(matrix, i, j, valor);
        } else {
            printf( "Posicao invalida\n" );
        }
    }
    return matrix;
}

void matrix_heads_line( Matrix* m, int a ) {
    Matrix* new = ( Matrix* ) malloc ( sizeof( Matrix ) );
    Matrix* aux = m->below;

    while( aux->below != m ) {
        aux = aux->below;
    }
    new->line = a;
    new->column = -1;
    aux->below = new;
    new->below = m;
    new->right = new;
}

void matrix_heads_column( Matrix* m, int a ) {
    Matrix* new = ( Matrix* ) malloc ( sizeof( Matrix ) );
    Matrix* aux = m->right;

    while( aux->right != m ) {
        aux = aux->right;
    }
    new->line = -1;
    new->column = a;
    aux->right = new;
    new->right = m;
    new->below = new;
}

//Pesquisei como percorrer uma matriz encadeada circular
//utilizei a mesma logica para o print
//não sei se é do jeito que imaginavas
void matrix_destroy( Matrix* m ) { // (atualização -> possui leak)
    if( m == NULL ) {
        return;
    }
    Matrix* r_head = m;
    Matrix* aux = r_head->below;
    while( aux != r_head ) {
        Matrix* temp = aux->right;
        while ( temp != aux ) {
            Matrix* temp_2 = temp->right;
            free( temp );
            temp = temp_2;
        }
        Matrix* r_next = aux->below;
        free( aux );
        aux = r_next;
    }
  
    free( m ); 
}

void matrix_print(Matrix* m) { // Ainda não consegui acertar o codigo: se houver a inserção na posição (0,0) e nenhuma mais nessa linha o programa não insere os 0.00 no restante das posições.
    if( m == NULL ) {
        printf("\nA matriz esta vazia\n");
        return;
    }

    Matrix* r_head = m;
    Matrix* aux_row = r_head->below;

    while( aux_row != r_head ) {
        Matrix* aux_col = aux_row->right;
        int constante = 0;// teste com inserção para saber qual a coluna ( a ideia é servir de apoio para posições sem valores);
        while( aux_col != aux_row ) {
            while( constante < aux_col->column ) {
                printf( "%.2f\t", 0.00 );
                constante++;
            }
            printf( "%.2f\t", aux_col->info );
            constante = aux_col->column + 1;
            aux_col = aux_col->right;
        }
        while( constante < r_head->column ) {
            printf( "%.2f\t", 0.00 );
            constante++;
        }
        printf( "\n" );
        aux_row = aux_row->below;
    }
}

Matrix* matrix_create_with_values( int m, int n, float** values ) {
    Matrix* matrix = ( Matrix* )malloc( sizeof( Matrix ) );

    matrix->line = m ; 
    matrix->column = n ; 
    matrix->right = matrix;
    matrix->below = matrix;

    for( int a = 0; a < m; a++ ) {
        matrix_heads_line( matrix, a );
    }
    for( int b = 0; b < n; b++ ) {
        matrix_heads_column( matrix, b );
    }
    /*for( int i = 0; i < m; i++ ) {
        for( int j = 0; j < n; j++ ) {
            float value = values[i][j];
            matrix_setelem( matrix, i, j, value );
        }
    }*/

    return matrix;
}


Matrix* matrix_add( Matrix* m, Matrix* n ) {
    if( m == NULL || n == NULL || m->line != n->line || m->column != n->column ) {
        return NULL;
    }

    int linhas = m->line;
    int colunas = m->column;

    Matrix* res = matrix_create_with_values( linhas, colunas, 0 );

    for( int i = 0; i < linhas; i++ ) {
        for( int j = 0; j < colunas; j++ ) {
            float sum = matrix_getelem( m, i, j ) + matrix_getelem( n, i, j );
            matrix_setelem( res, i, j, sum );
        }
    }

    return res;
}

Matrix* matrix_multiply( Matrix* m, Matrix* n ) {
    if( m == NULL || n == NULL || m->column != n->line ) {
        return NULL;
    }

    int linhas = m->line;
    int colunas = n->column;

    Matrix* res = matrix_create_with_values( linhas, colunas, 0 );

    for( int i = 0; i < linhas; i++ ) {
        for( int j = 0; j < colunas; j++ ) {
            float sum = 0.0;
            for( int k = 0; k < m->column + 1; k++ ) {
                sum += matrix_getelem( m, i, k ) * matrix_getelem( n, k, j );
            }
            matrix_setelem( res, i, j, sum );
        }
    }

    return res;
}

Matrix* matrix_transpose( Matrix* m ) {
    if( m == NULL ) {
        return NULL;
    }

    int linhas = m->column;
    int colunas = m->line ;

    Matrix* res = matrix_create_with_values(linhas, colunas, 0);

    for( int i = 0; i < linhas; i++ ) {
        for( int j = 0; j < colunas; j++ ) {
            float value = matrix_getelem( m, j, i );
            matrix_setelem( res, i, j, value );
        }
    }

    return res;
}

float matrix_getelem( Matrix* m, int x, int y ) {// retorna o valor da coordenada [x][y]?
    if( m == NULL || x < 0 || y < 0 ) {
        return 0.00;
    }
    Matrix* r_head = m;
    Matrix* aux = r_head->below;
  	while ( aux != r_head || aux->line != x ) {
	    aux = aux->below;
    } 
 	if( aux == r_head ) {//Os dois if's são para linhas ou colunas inexistentes -- talvez dê para n colocar nada?
	    return 0.00;
	} 
	Matrix* temp = aux->right;
	while( temp != aux || temp->column != y ) {
		temp = temp->right;
	}
	if( temp == aux ) {
	    return 0.00;
	}
	
    return temp->info;
}

void matrix_setelem( Matrix* m, int x, int y, float elem ) {
    if( m == NULL || x < 0 || y < 0 ) {//Dei uma arrumada aqui a tua logica tava certa mas tu não tinha feito o percurso para chegar na posição que tu queria chegar
        return;
    }

    Matrix* r_head = m;
    Matrix* aux = r_head->below;
    while( aux != r_head && aux->line != x ) {
	    aux = aux->below;
    } 
    if( aux == r_head ) {
        return;
    } 
    Matrix* temp_1 = aux;
    Matrix* temp_2 = aux->right;
    while( temp_2 != aux && temp_2->column != y ) {
	    temp_1 = temp_2;
	    temp_2 = temp_2->right;
    } 
    if( temp_2 != aux && aux->column == y ) {
        temp_2->info = elem;
    } else {
        Matrix* new = ( Matrix* ) malloc ( sizeof( Matrix ) );
        new->line = x;
        new->column = y;
        new->info = elem;
        new->right = temp_2;
        temp_1->right = new;
        if( aux->below == r_head ) {
            new->below = m;
        } else {
            new->below = aux->below;
        }
    }
  //Criando uma caixinha para adicionar o valor, porém também essa área também pode servir apenas
  //para trocar o valor de um nodo já existente.
}